j<!DOCTYPE html>
<html>
  <head>
    <title>Deep Learning Lectures</title>
    <meta charset="utf-8">
    <style>
     .left-column {
       width: 50%;
       float: left;
     }
     .small { font-size: 0.2em; }
     .right-column {
       width: 50%;
       float: right;
     }
     .footnote {
        position: absolute;
        bottom: 3em;
        margin: 0em 2em;
      }
     .grey { color: #bbbbbb; }
      </style>
    <link rel="stylesheet" type="text/css" href="slides.css">
  </head>
  <body>
      <textarea id="source">
class: center, middle

# Embeddings and Optimization

Roman Yurchak

Course material by Charles Ollion - Olivier Grisel

.affiliations[
  ![Heuritech](images/heuritech-logo.png)
  ![Inria](images/inria-logo.png)
  ![UPS](images/Logo_Master_Datascience.png)
]

---
# Outline

### Embeddings

--

### Dropout Regularization

--

---
class: middle, center

# Embeddings

---
# Symbolic variable

- Text: characters, words, bigrams...

- <span style="color:#cccccc">Recommender Systems: item ids, user ids</span>

- <span style="color:#cccccc">Any categorical descriptor: tags, movie genres, visited URLs, skills on a resume, product categories...</span>

---
# Symbolic variable

- Text: characters, words, bigrams...

- Recommender Systems: item ids, user ids 

- <span style="color:#cccccc">Any categorical descriptor: tags, movie genres, visited URLs, skills on a resume, product categories...</span>

---
# Symbolic variable

- Text: characters, words, bigrams...

- Recommender Systems: item ids, user ids 

- Any categorical descriptor: tags, movie genres, visited URLs, skills on a resume, product categories...

--

### Notation:

.center[
### Symbol $s$ in vocabulary $V$
]

---
# One-hot representation

$$onehot(\text{'salad'}) = [0, 0, 1, ..., 0] \in \\{0, 1\\}^{|V|}$$


.center[
          <img src="images/word_onehot.svg" style="width: 400px;" />
]

--

<br/>

- Sparse, discrete, large dimension $|V|$
- Each axis has a meaning
- Symbols are equidistant from each other:

.center[euclidean distance = $\sqrt{2}$]

---
# Embedding

$$embedding(\text{'salad'}) = [3.28, -0.45, ... 7.11] \in \mathbb{R}^d$$

--

<br/> 

- Continuous and dense
- Can represent a huge vocabulary in low dimension, typically: $d \in \\{16, 32, ..., 4096\\}$
- Axis have no meaning _a priori_
- Embedding metric can capture semantic distance

--

<br/>

**Neural Networks compute transformations on continuous vectors**

???
 _Yann Le Cun_ : "compute symbolic operations in algebraic space makes it possible to optimize via gradient descent"

---
# Implementation with Keras

Size of vocabulary $n = |V|$, size of embedding $d$

```py
# input: batch of integers
Embedding(output_dim=d, input_dim=n, input_length=1)
# output: batch of float vectors
```

--
- Equivalent to one-hot encoding multiplied by a weight matrix $\mathbf{W} \in \mathbb{R}^{n \times d}$:

$$embedding(x) = onehot(x) . \mathbf{W}$$

--
- $\mathbf{W}$ is typically **randomly initialized**, then **tuned by backprop**

--
- $\mathbf{W}$ are trainable parameters of the model

---
# Distance and similarity in Embedding space

.left-column[
### Euclidean distance

$d(x,y) = || x - y ||_2$

- Simple with good properties
- Dependent on norm (embeddings usually unconstrained)
]

--

.right-column[
### Cosine similarity

$cosine(x,y) = \frac{x \cdot y}{||x|| \cdot ||y||}$

- Angle between points, regardless of norm
- $cosine(x,y) \in (-1,1)$
- Expected cosine similarity of random pairs of vectors is $0$ 

]

---
# Distance and similarity in Embedding space

If $x$ and $y$ both have unit norms:

$$|| x - y ||_2^2 = 2 \cdot (1 - cosine(x, y))$$

--
or alternatively:

$$cosine(x, y) = 1 - \frac{|| x - y ||_2^2}{2}$$

--

Alternatively, dot product (unnormalized) is used in practice as a pseudo similarity 

---
# Visualizing Embeddings

- Visualizing requires a projection in 2 or 3 dimensions
- Objective: visualize which embedded symbols are similar

--

### PCA

- Limited by linear projection, embeddings usually have complex high dimensional structure

--

### t-SNE

          <small>
              Visualizing data using t-SNE, L van der Maaten, G Hinton, _The Journal of Machine Learning Research_, 2008 <br/>
          </small>


???
https://colah.github.io/posts/2014-10-Visualizing-MNIST/
---
# t-Distributed Stochastic Neighbor Embedding


 - Unsupervised, low-dimension, non-linear projection
 - Optimized to keep relative distance between nearest neighbors

<br/>

--

### t-SNE projection is non deterministic (depends on initialization)
 - Critical parameter: perplexity, usually set to 20, 30
 - See http://distill.pub/2016/misread-tsne/

---
#Example word vectors

.center[
          <img src="images/tsne_words.png" style="width: 630px;" /><br/>
          <small>excerpt from work by J. Turian on a model trained by R. Collobert et al. 2008</small>
]

---
# Visualizing Mnist

.center[
          <img src="images/mnist_tsne.jpg" style="width: 400px;" />
]

---

class: middle, center

# Dropout Regularization

---

# Regularization

### Size of the embeddings

--

### Depth of the network

--

### $L_2$ penalty on embeddings

--

### Dropout

- Randomly set activations to $0$ with probability $p$
- Bernoulli mask sampled for a forward pass / backward pass pair
- Typically only enabled at training time

---
# Dropout

.center[
          <img src="images/dropout.png" style="width: 680px;" />
]

.footnote.small[Dropout: A Simple Way to Prevent Neural Networks from Overfitting,
Srivastava et al., _Journal of Machine Learning Research_ 2014]

---
# Dropout

### Interpretation

- Reduces the network dependency to individual neurons
- More redundant representation of data

### Ensemble interpretation

- Equivalent to training a large ensemble of shared-parameters, binary-masked models
- Each model is only trained on a single data point

---
#Dropout

.center[
          <img src="images/dropout_traintest.png" style="width: 600px;" /><br/>

]
          <br/>

At test time, multiply weights by $p$ to keep same level of activation

.footnote.small[Dropout: A Simple Way to Prevent Neural Networks from Overfitting,
Srivastava et al., _Journal of Machine Learning Research_ 2014]

---
# Overfitting Noise

.center[
          <img src="images/dropout_curves_1.svg" style="width: 600px;" /><br/>
]

???
This dataset has few samples and ~10% noisy labels.
The model is seriously overparametrized (3 wide hidden layers).
The training loss goes to zero while the validation stops decreasing
after a few epochs and starts increasing again: this is a serious case
of overfitting.

---
# A bit of Dropout

.center[
          <img src="images/dropout_curves_2.svg" style="width: 600px;" /><br/>
]

???
With dropout the training speed is much slower and the training loss
has many random bumps caused by the additional variance in the updates
of SGD with dropout.

The validation loss on the other hand stays closer to the training loss
and can reach a slightly lower level than the model without dropout:
overfitting is reduced but not completely solved.

---
# Too much: Underfitting

.center[
          <img src="images/dropout_curves_3.svg" style="width: 600px;" /><br/>
]

---
# Implementation with Keras

<br/>
<br/>
```py
model = Sequential()
model.add(Dense(hidden_size, input_shape, activation='relu'))
*model.add(Dropout(p=0.5))
model.add(Dense(hidden_size, activation='relu'))
*model.add(Dropout(p=0.5))
model.add(Dense(output_size, activation='softmax'))
```

???

In practice, activations are multiplied by $\frac{1}{p}$ at train time, test time is unchanged

---

# Batch Normalization

Normalize activations in each **mini-batch** before activation function:
**speeds up** and **stabilizes** training (less dependent on init)

.footnote.small[
Ioffe, Sergey, and Christian Szegedy. "Batch normalization:
Accelerating deep network training by reducing internal covariate
shift." ICML 2015
]

--
.center[
<img src="images/batchnorm.png" style="width: 450px;" />
]

???
Used successfully in conjunction to residual connection.

---
# Batch Normalization

At **inference time**, use average and standard deviation computed on
**the whole dataset** instead of batch

--

Widely used in **ConvNets**, but requires the mini-batch to be large
enough to compute statistics in the minibatch.

--

In **Keras**: use it as a layer, before activation	
	
```python
x = Convolution2D(64, 1, 1)(input_tensor)
x = BatchNormalization()(x)
x = Activation('relu')(x)
```

--

- Introduces new parameters: `2 x size_of_activation` (here 128)

--
- Keras keeps track of a **running average/std** of activations for
  inference, no need to have specific inference code.


    </textarea>
    <style TYPE="text/css">
      code.has-jax {font: inherit; font-size: 100%; background: inherit; border: inherit;}
    </style>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
      tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'] // removed 'code' entry
      }
      });
      MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i = 0; i < all.length; i += 1) {
		     all[i].SourceElement().parentNode.className += ' has-jax';
		     }
		     });
		     </script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="../remark.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create({
        highlightStyle: 'github',
        highlightSpans: true,
        highlightLines: true
      });
    </script>
  </body>
</html>
